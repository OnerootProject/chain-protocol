/*
 * Copyright (C) 2019 The oneroot-network Authors
 * This file is part of The onerootchain library.
 *
 * The onerootchain is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The onerootchain is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with The onerootchain.  If not, see <http://www.gnu.org/licenses/>.
 */

package utils

import (
	errors2 "errors"
	"github.com/oneroot-network/onerootchain/common/errors"
	cotrcom "github.com/oneroot-network/onerootchain/core/contract/common"
	"github.com/oneroot-network/onerootchain/core/contract/native/common"
	"github.com/oneroot-network/onerootchain/core/contract/native/token"
	"github.com/oneroot-network/onerootchain/core/states"
	"github.com/oneroot-network/onerootchain/core/types"
	"math"
	"strconv"
	"strings"
)

const (
	KeyPrefixBalance         = 0x01
	KeyPrefixCurrentRound    = 0x02
	KeyPrefixPrepareWithdraw = 0x03
	KeyPrefixSpProfit        = 0x04
	KeyPrefixDWithdraw       = 0x06
	KeyPrefixRelay           = 0x0a
	KeyPrefixOrder           = 0x0b
	KeyPrefixDCancelOrder    = 0x0c
)

const PrefixLen = types.AddressSize + 1
const ZERO = "0000000000"

func Uint64ToDecimal(v uint64, decimal uint8) string {
	p := uint64(math.Pow10(int(decimal)))
	d := v / p
	dot := v % p
	in := strconv.FormatUint(d, 10)
	if dot == 0 {
		return in
	}
	dec := strconv.FormatUint(dot, 10)
	k := len(dec)
	if k < int(decimal) {
		//add 0 before dec
		dec = ZERO[:int(decimal)-k] + dec
	}
	return in + "." + dec
}

func DecimalToUint64(number string, decimal uint8) (uint64, error) {
	s := strings.Split(number, ".")
	ss := s[0]
	switch len(s) {
	case 1:
		ss += ZERO[:decimal]
	case 2:
		k := len(s[1])
		if k > int(decimal) {
			return 0, errors2.New(" number and precision unexpected")
		}
		ss = ss + s[1] + ZERO[:int(decimal)-k]
	}
	res, err := strconv.ParseUint(ss, 10, 64)
	if err != nil {
		return 0, err
	}
	return res, nil
}

//get the balance key of dex.generated by contract,account address,token address
func GetBalanceKey(address, token types.Address) string {
	return states.NewContractDataKeyBuilder(types.AddressSize*3 + 1).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixBalance).
		PutBytes(address.ToArray()).
		PutBytes(token.ToArray()).
		GetKey()
}

func GetPairKey(prefix byte, base, quote types.Address) string {
	return states.NewContractDataKeyBuilder(types.AddressSize*3 + 1).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(prefix).
		PutBytes(base.ToArray()).
		PutBytes(quote.ToArray()).
		GetKey()
}
func GetDWithdrawKey(hash []byte) string {
	return states.NewContractDataKeyBuilder(PrefixLen + len(hash)).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixDWithdraw).
		PutBytes(hash).
		GetKey()
}
func GetPreparedWithdrawKey(address, token types.Address) string {
	return states.NewContractDataKeyBuilder(PrefixLen + types.AddressSize*2).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixPrepareWithdraw).
		PutBytes(address.ToArray()).
		PutBytes(token.ToArray()).
		GetKey()
}
func GetAccountKey(prefix byte, user types.Address) string {
	return states.NewContractDataKeyBuilder(PrefixLen + types.AddressSize).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(prefix).
		PutBytes(user.ToArray()).
		GetKey()
}

func GetOrderIdKey(orderId []byte) string {
	return states.NewContractDataKeyBuilder(PrefixLen + len(orderId)).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixOrder).
		PutBytes(orderId).
		GetKey()
}
func GetPrefixKey(prefix byte) string {
	return states.NewContractDataKeyBuilder(PrefixLen).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(prefix).
		GetKey()
}

func GetCurrentRoundKey() string {
	return states.NewContractDataKeyBuilder(types.AddressSize + 1).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixCurrentRound).
		GetKey()
}

func GetSpProfitKey(asset types.Address) string {
	return states.NewContractDataKeyBuilder(types.AddressSize*2 + 1).
		PutBytes(common.DexAddress.ToArray()).
		PutByte(KeyPrefixSpProfit).
		PutBytes(asset.ToArray()).
		GetKey()
}
func GetTokenDecimal(ref cotrcom.ContractRef, asset *types.Account) (uint8, errors.Error) {
	engine, cErr := ref.NewExecuteEngine(asset, token.Decimal, []byte{})
	if cErr != errors.ErrOK {
		return 0, cErr
	}
	res, cErr := engine.Invoke()
	if cErr != errors.ErrOK {
		return 0, cErr
	}
	if res == nil {
		return 0, errors.ErrOrderTokenDecimalNull
	}
	return res.(uint8), cErr
}
